\documentclass[a4paper, 11pt]{article}

%Comandos para configurar el idioma
\usepackage[spanish,activeacute]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} %Necesario para el uso de las comillas latinas.
\usepackage{geometry}

%Importante que esta sea la última órden del preámbulo
\usepackage{hyperref}

\newcommand\fnurl[2]{%
  \href{#2}{#1}\footnote{\url{#2}}%
}

%Paquetes matemáticos
\usepackage{amsmath,amsfonts,amsthm}
\usepackage[all]{xy} %Para diagramas
\usepackage{enumerate} %Personalización de enumeraciones
\usepackage{tikz} %Dibujos

%Tipografía escalable
\usepackage{lmodern}
%Legibilidad
\usepackage{microtype}

%Código
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\definecolor{listinggray}{gray}{0.9}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
backgroundcolor=\color{lbcolor},
    tabsize=4,
rulecolor=,
    language=[GNU]C++,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=false,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        numbers=left,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.026,0.112,0.095},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numberstyle=\color[rgb]{0.205, 0.142, 0.73},
%        \lstdefinestyle{C++}{language=C++,style=numbers}’.
}
\lstset{
    backgroundcolor=\color{lbcolor},
    tabsize=4,
  language=C++,
  captionpos=b,
  tabsize=3,
  frame=lines,
  numbers=left,
  numberstyle=\tiny,
  numbersep=5pt,
  breaklines=true,
  showstringspaces=false,
  basicstyle=\footnotesize,
%  identifierstyle=\color{magenta},
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.026,0.112,0.095}, % Darkgreen
  stringstyle=\color{red}
  }
% Slightly bigger margins than the latex defaults

\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}

\theoremstyle{definition}
\newtheorem{ejercicio}{Ejercicio}
\newtheorem{cuestion}{Cuestión}
\newtheorem*{solucion}{Solución}
\newtheorem*{bonus}{BONUS}

%%%%%%%% New sqrt
\usepackage{letltxmacro}
\makeatletter
\let\oldr@@t\r@@t
\def\r@@t#1#2{%
\setbox0=\hbox{$\oldr@@t#1{#2\,}$}\dimen0=\ht0
\advance\dimen0-0.2\ht0
\setbox2=\hbox{\vrule height\ht0 depth -\dimen0}%
{\box0\lower0.4pt\box2}}
\LetLtxMacro{\oldsqrt}{\sqrt}
\renewcommand*{\sqrt}[2][\ ]{\oldsqrt[#1]{#2} }
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\hypersetup{
  pdftitle={Informe de trabajo 1},
  pdfauthor={Antonio Álvarez Caballero},
  unicode,
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

\title{Informe de trabajo 1}
\author{Antonio Álvarez Caballero\\
    \href{mailto:analca3@correo.ugr.es}{analca3@correo.ugr.es}}
\date{}
%%%%%%%%%%%%%%%%% FIN PREAMBULO %%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

  \maketitle

  \section{Convolución}

  La primera parte de la práctica consiste en aplicar un filtro de convolución
  (en este caso, un filtro de alisamiento Gaussiano) a una imagen. Para ello,
  partiendo de la función Gaussiana en una sola variable (recordamos que este filtro
  es separable en filas y columnas), realizaremos una serie de pasos.

  \subsection{Creación del vector máscara}

  El primero de ellos será, a partir de la función proporcionada $f(x)=exp(-0.5\frac{x^2}{\sigma^2})$
  y de un valor $\sigma$ , generar un vector máscara representativo. Para conseguirlo,
  debemos recordar que para que la máscara sea significativa debe contener la región
  $[-3\sigma,3\sigma]$. Sabiendo esto, la longitud de la máscara podremos conseguirla
  aplicando en \textit{C++} esta operación:
  es

  \begin{lstlisting}
    float dimension = 2*round(3*sigma) + 1;
  \end{lstlisting}

  ¿Por qué? Pues porque así conseguimos discretizar $3\sigma$ y que la máscara
  tenga en ambos lados dicha longitud. Luego sumamos $1$ para contar también el centro.\\

  Una vez tenemos la dimensión de la máscara, debemos aplicar $f(x)$ a los índices
  de nuestra máscara. Es decir, para $\sigma = 1$, la dimensión sería $7$, y los
  índices de la máscara $[-3,-2,-1,0,1,2,3]$, pues debemos aplicar $f(x)$ a dichos
  valores para obtener nuestro vector máscara. No debemos olvidarnos de normalizar
  la máscara como último paso.

  \begin{lstlisting}
    Mat Image::gaussianMask(float sigma)
    {
      int mask_size = 2 * round(3 * sigma) + 1; // +-3*sigma plus the zero
      int mask_center = round(3 * sigma);

      float value = 0, sum_values = 0;
      int mask_index;

      Mat mask = Mat::zeros(1, mask_size, CV_32FC1);

      for (int i = 0; i < mask_size; i++)
      {
        mask_index = i - mask_center;
        value = exp(-0.5 * (mask_index * mask_index) / (sigma * sigma));

        mask.at<float>(Point(i,0)) = value;
        sum_values += value;
      }

      mask *= 1.0 / sum_values;

      return mask;
    }
  \end{lstlisting}

  \subsection{Aplicación del vector máscara sobre una fila}

  El siguiente paso es aplicar dicha máscara sobre un vector fila. Para ello, debemos
  expandir el vector de entrada (a partir de ahora, vector señal) para poder tomar
  algún píxel vecino a los de los extremos de la imagen, para poder pasar por ellos también
  la máscara. En este caso hemos trabajado con los modos \textit{Reflejado} y \textit{Constante}.
  Para ello hemos utilizado la función de OpenCV \textit{copyMakeBorder}, que es
  muy versátil y nos permite copiar una imagen en otra con un determinado borde.
  Nos permite también decidir el modo de expansión que queremos, que en nuestro caso,
  como hemos indicado, son \textit{Reflejado} y \textit{Constante}.\\

  La lógica es la siguiente: expandimos la imagen, y luego, vamos extrayendo
  un ROI del mismo tamaño de la máscara por todo el vector, realizando en cada
  iteración el producto escalar entre el ROI y la máscara. Este resultado lo vamos
  volcando en una imagen de salida.

  \begin{lstlisting}
    Mat Image::convolution1D1C(Mat &input, Mat &mask, bool reflected)
    {
      // Expand the matrix
      Mat expanded, copy_input;
      int borderType = BORDER_CONSTANT;
      int offset = (mask.cols - 1) / 2;

      if (reflected)
        borderType = BORDER_REFLECT;


      copyMakeBorder(input,expanded,0,0,offset,offset,borderType,0);

      // Convolution!
      Mat ROI;
      Mat output = Mat::zeros(1, input.cols, CV_32FC1);
      expanded.convertTo(expanded,CV_32FC1);

      for (int i = 0; i < input.cols; i++) // Index are OK
      {
        ROI = Mat(expanded, Rect(i,0,mask.cols,1));
        output.at<float>(Point(i,0)) = ROI.dot(mask);
      }

      return output;
    }
  \end{lstlisting}




\end{document}
